# Continuous Integration pipeline

name: "[On Pull]: CI/CD"
run-name: 'CI/CD: ${{github.ref}}'

on:
  pull_request:
    types:
      - labeled
      - unlabeled
      - reopened
      - synchronize


jobs:

  context:
    # Output summary of the workflow run's `github` context.
    # This job outputs a sanitized version of the `github` context as job summary,
    # for logging/debugging purposes.
    name: 'Workflow Run / context'
    runs-on: ubuntu-latest
    steps:
      - name: 'Checkout script'
        uses: actions/checkout@v3
        with:
          ref: ${{ github.base_ref }}
          sparse-checkout: .github/scripts/context_summary.py
          sparse-checkout-cone-mode: false

      - name: 'Generate context summary'
        run: python '.github/scripts/context_summary.py'
        env:
          GH_CONTEXT: ${{ toJson(github) }}


  changes:
    # Get all changed files/categories in the repository due to the push event.
    #
    # Returns
    # -------
    # json : str
    #     String representation of a JSON object.
    name: 'Repository Files'
    uses: ./.github/workflows/repo_changes.yaml


  metadata:
    # Load repository metadata.
    #
    # Returns
    # -------
    # json : str
    #     String representation of a JSON object containing the repository metadata.
    name: 'Repository Metadata'
    uses: ./.github/workflows/repo_meta.yaml


  package:
    name: 'Test package'
    needs: [changes, metadata]
    if: |
      fromJSON(needs.changes.outputs.json).package.any_modified == 'true' ||
      fromJSON(needs.changes.outputs.json).tests.any_modified == 'true'
    uses: ./.github/workflows/package_ci.yaml
    permissions:
      pull-requests: write
      security-events: write
      actions: read
      contents: read
    with:
      metadata: ${{needs.metadata.outputs.json}}
      checkout-ref: ${{ github.head_ref }}
      base-ref: ${{ github.base_ref }}
      head-ref: ${{ github.head_ref }}


  docs:
    name: 'Build documentation with Sphinx'
    needs: [changes]
    if: fromJSON(needs.changes.outputs.json).docs.any_modified == 'true'
    uses: ./.github/workflows/docs_build.yaml
    with:
      checkout-ref: ${{ github.head_ref }}


  publish-testpypi:
    name: 'Publish on TestPyPI'
    needs: [changes, package]
    if: |
      github.base_ref == 'main' &&
      fromJSON(needs.changes.outputs.json).package.any_modified == 'true'
#    always() &&
#    needs.build-package.result == 'success' &&
#    needs.test-local.result == 'success' &&
#    github.event_name == 'push' &&
#    github.ref == 'refs/heads/main'
    uses: ./.github/workflows/package_release_pypi.yaml
    permissions:
      id-token: write
    with:
      package-name: ${{ needs.package.outputs.package-name }}
      package-version: ${{ needs.package.outputs.package-version }}
      artifact-name: ${{ needs.package.outputs.artifact-name }}
      platform-name: 'testpypi'


  wait-for-testpypi:
    # Wait for 5 min before running the next job, to make sure package is registered at TestPyPI
    name: 'Wait for TestPyPI'
    needs: publish-testpypi
#    if: |
#      always() &&
#      needs.publish-testpypi.result == 'success'
    runs-on: ubuntu-latest
    steps:
      - name: 'Waiting ...'
        run: sleep 300s


  test-testpypi:
    name: 'Install and test from TestPyPI'
    needs: [ metadata, package, wait-for-testpypi ]
#    if: |
#      always() &&
#      needs.publish-testpypi.result == 'success'
    uses: ./.github/workflows/package_test.yaml
    with:
      metadata: ${{ needs.metadata.outputs.json }}
      install-source: "testpypi"
      install-version: ${{ needs.package.outputs.package-version }}
